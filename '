#include <vector>
#include <iostream>
#include <limits>

using namespace std;

class SegmentTree {
public:
    SegmentTree( vector<int> leaves ) {
        tree = vector<int>( 4 * leaves.size( ) );
        ( void ) build( leaves, 0, leaves.size( ) - 1, 1 );
        n = leaves.size( );
    }

    void update( int inc, int pos ) {
        ( void ) update( inc, pos, 0, n - 1 );
    }

    void update( int inc, int l, int r ) {
        ( void ) update( inc, l, r, 0, n - 1 );
    }
    int rmq( int r, int l ) {
        return rmq( 1, r, l, 0 , n - 1 );
    }

private:
    int left( int pos )     { return ( pos << 1 ); }
    int rigth( int pos )    { return ( pos << 1 ) + 1; } 

    void build( vector<int> leaves, int l, int r, int pos ) {
        if( l == r ) {
            tree[pos] = leaves[l];
            return leaves[i];
        }
        int mid = ( l - r + 1 ) / 2;
        int minL = build( leaves, l, l + mid - 1, left( pos ) );
        int minR = build( leaves, l + mid, r, right( pos ) );
        tree[pos] = ( minL < minR ) ? minL : minR;
    }

    int update( int pos, int inc, int node, int i, int j ) {
        if( pos < i || pos > j ) {
            return numeric_limits::max( );
        }
        if( i == j ) {
            tree[pos] += inc;
            return tree[i];
        }
        int mid = ( j - i + 1 ) / 2;
        int minI = update( pos, inc, left( node ), i, i + mid - 1 );
        int minJ = update( pos, inc, right( node ), i + mid, j );
        tree[node] = ( minI < minJ ) ? minI : minJ;
        return tree[node];
    }

    int update( int inc, int l, int r, int i, int j ) {
        if( ( r < i && l < i ) || ( r > j && l > j ) ) {
            return numeric_limits<int>::max( );
        }
        if( i == j ) {
            tree[i] += inc;
            return tree[i];
        }
        int mid = ( j - i + 1 ) / 2;
        int minI = update( pos, inc, left( node ), i, i + mid - 1 );
        int minJ = update( pos, inc, right( node ), i + mid, j );
        tree[node] = ( minI < minJ ) ? minI : minJ;
        return tree[node];
    }
    
    int rmq( int pos, int r, int l, int i, int j ) {
        if( r <= i && l >= j ) {
            return tree[pos];
        } else if( ( r < i && l < i ) || ( l > j && r > j ) ) {
            return numeric_limits::max( );
        }
        int mid = ( i - j + 1 ) / 2;
        int minL = rmq( left( pos ), r, l, i, i + mid - 1 );
        int minR = rmq( right( pos ), r, l, i + mid, j );
        return ( minL < minR ) ? minL : minR;
    }

    vector<int> tree;
    int n;
};

int main( )
{
    ios::sync_with_stdio( false );
    return 0;
}
